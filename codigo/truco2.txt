#include <iostream>
#include "jogador.hpp"

// O enum 
enum EstadoTruco
{
    NORMAL = 1,
    TRUCO = 4,
    SEIS = 6,
    NOVE = 9,
    DOZE = 12,
    CORRER = -1
};

class Truco
{
private:

// Índice do último jogador que pediu/aumentou
    int quemPediu;
    Jogador jogador; 

    EstadoTruco estadoAtual;

public:
    
   void Resetar()
   {
    quemPediu = -1;
    estadoAtual = NORMAL;
   }

    // Retorna o estado atual da aposta
    EstadoTruco getEstado() const 
    {
        return estadoAtual;
    }

    // Jogador atual decide se quer pedir truco
    void pedirTruco(int jogadorIndex, const Jogador& jogador) 
    {
        // Só pode pedir truco se o estado for NORMAL
        if (estadoAtual != NORMAL) 
        {
            std::cout << "Acao invalida! Alguem ja pediu truco." << std::endl;
            return;
        }
        else
        {

            std::cout << "Jogador " << (jogadorIndex + 1) << ", suas cartas sao:\n";
            jogador.MostrarCarta();

            std::cout << "Jogador " << (jogadorIndex + 1) << ", quer pedir TRUCO?" << std::endl;
            std::cout << "[1] Sim\n[2] Nao" << std::endl;
            int escolha;
            std::cin >> escolha;

                 if (escolha == 1)
                 {
                    std::cout << "Jogador " << (jogadorIndex + 1) << " pediu TRUCO!" << std::endl;
                    this->estadoAtual = TRUCO;
                    this->quemPediu = jogadorIndex;

                    //o outro jogador deve responder
                    responder( (jogadorIndex + 1) % 2, jogador );
                }
        }
    }

    // Lida com a resposta do jogador desafiado
    void responder(int jogadorIndex, const Jogador& jogador) {
        std::cout << "--------------------------------" << std::endl;
        std::cout << "Jogador " << (jogadorIndex + 1) << ", voce foi Trucado!" << std::endl;

        std::cout << "Suas cartas:\n";
        jogador.MostrarCarta();


        // Determina o próximo valor da aposta
        EstadoTruco proximoEstado = NORMAL;
        switch (estadoAtual) {
            case TRUCO: proximoEstado = SEIS; break;
            case SEIS:  proximoEstado = NOVE; break;
            case NOVE:  proximoEstado = DOZE; break;
            default: break; 
        }
        
        std::cout << "[1] Aceitar\n[2] Correr" << std::endl;
        // Só pode aumentar se não for o valor máximo (DOZE)
        if(estadoAtual != DOZE) {
             std::cout << "[3] Pedir " << proximoEstado << std::endl;
        }
       
        int escolha;
        std::cin >> escolha;

        if (escolha == 1) { // ACEITAR
            std::cout << "Jogador " << (jogadorIndex + 1) << " aceitou!" << std::endl;
        } 
        else if (escolha == 2) { // CORRER
            std::cout << "Jogador " << (jogadorIndex + 1) << " correu!" << std::endl;
            this->estadoAtual = CORRER;
        }
        else if (escolha == 3 && estadoAtual != DOZE) { // AUMENTAR
            std::cout << "Jogador " << (jogadorIndex + 1) << " pediu " << proximoEstado << "!" << std::endl;
            this->estadoAtual = proximoEstado;
            this->quemPediu = jogadorIndex;
            // Inverte o desafio, o outro jogador responde
            responder( (jogadorIndex + 1) % 2, jogador );
        }
        else {
            std::cout << "Opcao invalida. Considerando como 'Correr'." << std::endl;
            this->estadoAtual = CORRER;
        }
    }
    
    // Retorna o índice do jogador que perdeu a aposta (quem correu)
    int getQuemCorreu() const {
        if (estadoAtual == CORRER) {
            // Quem corre é o jogador que estava respondendo ao desafio.
            // O último a pedir (`quemPediu`) é quem ganhou o ponto.
            // Logo, quem correu é o outro.
            return (quemPediu + 1) % 2;
        }
        return -1; // Ninguém correu
    }
};